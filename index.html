<!--
  To deploy this game to Vercel:
  1. Push this file to your GitHub repository (e.g., in a /game or / root folder).
  2. Add a vercel.json file with the following content:
     {
       "rewrites": [{ "source": "/(.*)", "destination": "/index.html" }],
       "cleanUrls": true
     }
  3. Connect the repo to Vercel and deploy as a static site.
  This file is fully self-contained and ready for static hosting.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hexpert</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      background: #f4f5f7;
      font-family: 'Quicksand', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    .start-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100vw;
      position: fixed;
      top: 0;
      left: 0;
      background: #f4f5f7;
      z-index: 10;
      transition: opacity 0.4s;
    }
    .start-title {
      font-family: 'Montserrat', Arial, sans-serif;
      font-size: 2.8em;
      color: #3a3a3a;
      letter-spacing: 0.04em;
      margin-bottom: 0.5em;
      text-shadow: 0 2px 12px #bfc3c7;
    }
    .start-desc {
      color: #6b6e72;
      font-size: 1.2em;
      margin-bottom: 2em;
      max-width: 400px;
      text-align: center;
    }
    .start-btn {
      font-family: 'Montserrat', Arial, sans-serif;
      font-size: 1.2em;
      background: #bfc3c7;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 14px 38px;
      cursor: pointer;
      box-shadow: 0 2px 8px #bfc3c755;
      transition: background 0.2s, box-shadow 0.2s;
      font-weight: 700;
      letter-spacing: 0.04em;
    }
    .start-btn:hover {
      background: #a2a6aa;
      box-shadow: 0 4px 16px #bfc3c799;
    }
    h1 {
      margin-top: 24px;
    }
    #game {
      margin-top: 32px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 4px 32px #bfc3c733;
      padding: 32px 24px 24px 24px;
      min-width: 380px;
      min-height: 420px;
    }
    .row {
      display: flex;
      justify-content: center;
      margin-bottom: -34px; /* overlap rows so hexagons touch vertically (about half the height minus border) */
    }
    .hex {
      width: 60px;
      height: 69px;
      margin: 0 -4px; /* reduce horizontal gap between columns */
      box-sizing: border-box;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2em;
      user-select: none;
      background: none;
      padding: 0;
      position: relative;
      transition: box-shadow 0.2s, transform 0.2s;
      border-radius: 8px;
    }
    .hex:hover:not(.disabled) {
      box-shadow: 0 2px 12px #bfc3c744;
      transform: scale(1.04);
      z-index: 2;
    }
    .hex svg {
      width: 60px;
      height: 69px;
      display: block;
    }
    .hex .label {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2em;
      pointer-events: none;
      font-family: 'Montserrat', Arial, sans-serif;
    }
    .hex.player svg polygon {
      fill: #d97c7c;
      stroke: #a94c4c;
    }
    .hex.trail-1 svg polygon {
      fill: rgba(217, 124, 124, 0.7);
    }
    .hex.trail-2 svg polygon {
      fill: rgba(217, 124, 124, 0.5);
    }
    .hex.trail-3 svg polygon {
      fill: rgba(217, 124, 124, 0.3);
    }
    .hex.trail-4 svg polygon {
      fill: rgba(217, 124, 124, 0.15);
    }
    .hex.ctr-1 svg polygon {
      fill: rgba(52, 152, 219, 0.8);
    }
    .hex.ctr-2 svg polygon {
      fill: rgba(52, 152, 219, 0.6);
    }
    .hex.ctr-3 svg polygon {
      fill: rgba(52, 152, 219, 0.4);
    }
    .hex.ctr-4 svg polygon {
      fill: rgba(52, 152, 219, 0.2);
    }
    .hex.computer-ghost svg polygon {
      fill: url(#ghostPattern);
      stroke: #217dbb;
    }
    .hex.goal svg polygon {
      stroke: #3498db;
    }
    .hex.start svg polygon {
      stroke: #e74c3c;
    }
    .hex.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .hex svg polygon {
      fill: #eaeaea;
      stroke: #bbb;
      stroke-width: 4;
      transition: fill 0.2s, stroke 0.2s;
    }
    #message {
      margin-top: 24px;
      font-size: 1.2em;
      min-height: 1.5em;
    }
    #reset {
      margin-top: 16px;
      padding: 8px 20px;
      font-size: 1em;
      border-radius: 8px;
      border: none;
      background: #bfc3c7;
      color: #fff;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
      font-family: 'Montserrat', Arial, sans-serif;
      font-weight: 700;
      letter-spacing: 0.04em;
      box-shadow: 0 2px 8px #bfc3c755;
    }
    #reset:hover {
      background: #a2a6aa;
      box-shadow: 0 4px 16px #bfc3c799;
    }
    /* Honeycomb stagger: odd columns are shifted down */
    .hex.stagger {
      margin-top: 34px;
    }
    .hex.collision svg polygon {
      stroke: #a580d9;
      stroke-width: 8;
      fill: #d1c2e9;
      filter: drop-shadow(0 0 8px #d1c2e9);
      animation: flash-purple 0.5s linear 2;
    }
    @keyframes flash-purple {
      0%, 100% { filter: drop-shadow(0 0 8px #d1c2e9); }
      50% { filter: drop-shadow(0 0 24px #a580d9); }
    }
    #scoreboard {
      margin-top: 10px;
      font-size: 1.2em;
      display: flex;
      gap: 24px;
      justify-content: center;
      align-items: center;
      font-family: 'Montserrat', Arial, sans-serif;
    }
    .scorebox {
      padding: 8px 18px;
      border-radius: 10px;
      border: 3px solid transparent;
      font-weight: bold;
      font-size: 1.2em;
      min-width: 80px;
      text-align: center;
      background: #fff;
      transition: border 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px #0001;
      font-family: 'Montserrat', Arial, sans-serif;
    }
    .scorebox.active-player {
      border: 3px solid #d97c7c;
      box-shadow: 0 0 0 4px #d97c7c33;
    }
    .scorebox.active-computer {
      border: 3px solid #7c9fd9;
      box-shadow: 0 0 0 4px #7c9fd933;
    }
    .hex.computer svg polygon {
      fill: #7c9fd9;
      stroke: #4c6ea9;
    }
    .hex.computer-reveal svg polygon {
      fill: #7c9fd9;
      stroke: #4c6ea9;
      opacity: 1;
      filter: drop-shadow(0 0 8px #7c9fd9);
    }
    .hex.computer-last svg polygon {
      fill: #7c9fd9;
      stroke: #4c6ea9;
      opacity: 0.8;
    }
    /* Decorative hexagons for start screen */
    .start-hex {
      position: absolute;
      opacity: 0.18;
      z-index: 1;
      pointer-events: none;
      transition: transform 0.7s cubic-bezier(.4,2,.3,1);
    }
    .start-hex1 { left: 12vw; top: 18vh; transform: rotate(-8deg) scale(1.2); }
    .start-hex2 { right: 10vw; top: 10vh; transform: rotate(12deg) scale(0.9); }
    .start-hex3 { left: 22vw; bottom: 12vh; transform: rotate(6deg) scale(1.1); }
    .start-hex4 { right: 18vw; bottom: 16vh; transform: rotate(-14deg) scale(0.8); }
    .start-hex5 { left: 50vw; top: 50vh; transform: rotate(0deg) scale(1.5); opacity: 0.08; }
    .hex.flash-blue svg polygon {
      stroke: #4c6ea9;
      stroke-width: 8;
      fill: #7c9fd9;
      filter: drop-shadow(0 0 12px #7c9fd9);
      animation: flash-row-blue 0.6s linear 1;
    }
    @keyframes flash-row-blue {
      0%, 100% { filter: drop-shadow(0 0 12px #7c9fd9); opacity: 1; }
      50% { filter: drop-shadow(0 0 32px #4c6ea9); opacity: 0.7; }
    }
    .hex.flash-red svg polygon {
      stroke: #a94c4c;
      stroke-width: 8;
      fill: #d97c7c;
      filter: drop-shadow(0 0 12px #d97c7c);
      animation: flash-row-red 0.6s linear 1;
    }
    @keyframes flash-row-red {
      0%, 100% { filter: drop-shadow(0 0 12px #d97c7c); opacity: 1; }
      50% { filter: drop-shadow(0 0 32px #a94c4c); opacity: 0.7; }
    }
    .start-honeycomb {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -54%);
      z-index: 2;
      pointer-events: none;
      opacity: 0.22;
      filter: blur(0.5px) drop-shadow(0 2px 16px #bfc3c7cc);
    }
    .start-screen .start-title,
    .start-screen .start-desc,
    .start-screen .start-btn {
      position: relative;
      z-index: 3;
    }
    .start-screen .start-btn {
      margin-top: 1.5em;
    }
    .hex.flash-gold svg polygon {
      stroke: #bfa73a;
      stroke-width: 8;
      fill: #ffe066;
      filter: drop-shadow(0 0 16px #ffe066);
      animation: flash-gold 1.1s linear 1;
    }
    @keyframes flash-gold {
      0%, 100% { filter: drop-shadow(0 0 16px #ffe066); opacity: 1; }
      50% { filter: drop-shadow(0 0 48px #bfa73a); opacity: 0.7; }
    }
    .confetti {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 100;
      overflow: hidden;
    }
    .confetti-piece {
      position: absolute;
      width: 12px; height: 12px;
      border-radius: 2px;
      opacity: 0.85;
      animation: confetti-fall 1.2s linear forwards;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-40px) rotate(0deg); }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0.2; }
    }
    @media (max-width: 600px) {
      #game {
        min-width: unset;
        padding: 16px 4px 12px 4px;
        border-radius: 12px;
      }
      .hex {
        width: 38px;
        height: 44px;
        font-size: 1em;
      }
      .hex svg {
        width: 38px;
        height: 44px;
      }
      .row {
        margin-bottom: -22px;
      }
      .scorebox {
        padding: 6px 8px;
        font-size: 1em;
        min-width: 54px;
        border-radius: 7px;
      }
      #scoreboard {
        gap: 10px;
      }
      .start-title {
        font-size: 1.5em;
      }
      .start-desc {
        font-size: 1em;
        max-width: 90vw;
      }
      .start-btn {
        font-size: 1em;
        padding: 10px 18px;
        border-radius: 6px;
      }
      .start-honeycomb {
        width: 180px !important;
        height: 160px !important;
      }
      #reset {
        font-size: 0.95em;
        padding: 7px 12px;
        border-radius: 6px;
      }
    }
    @media (max-width: 400px) {
      .hex {
        width: 28px;
        height: 32px;
        font-size: 0.8em;
      }
      .hex svg {
        width: 28px;
        height: 32px;
      }
      .row {
        margin-bottom: -14px;
      }
      .scorebox {
        font-size: 0.85em;
        min-width: 36px;
        padding: 4px 4px;
      }
      .start-title {
        font-size: 1.1em;
      }
      .start-desc {
        font-size: 0.85em;
      }
      .start-btn {
        font-size: 0.9em;
        padding: 7px 10px;
      }
      .start-honeycomb {
        width: 110px !important;
        height: 90px !important;
      }
      #game {
        padding: 6px 0 6px 0;
        border-radius: 6px;
      }
    }
  </style>
</head>
<body>
  <div id="startScreen" class="start-screen">
    <div class="start-title">Hexpert</div>
    <div class="start-desc">A clean, modern hexagon puzzle game.<br>Try to reach the top without getting caught by Hexpert!</div>
    <button class="start-btn" id="startBtn">Start Game</button>
    <svg class="start-honeycomb" width="340" height="320" viewBox="0 0 340 320">
      <g>
        <polygon points="170,20 210,40 210,80 170,100 130,80 130,40" fill="#bfc3c7" stroke="#a2a6aa" stroke-width="4"/>
        <polygon points="210,40 250,60 250,100 210,120 170,100 170,60" fill="#d1c2e9" stroke="#a580d9" stroke-width="4"/>
        <polygon points="130,40 170,60 170,100 130,120 90,100 90,60" fill="#a580d9" stroke="#7c9fd9" stroke-width="4"/>
        <polygon points="170,100 210,120 210,160 170,180 130,160 130,120" fill="#7c9fd9" stroke="#4c6ea9" stroke-width="4"/>
        <polygon points="250,100 290,120 290,160 250,180 210,160 210,120" fill="#d97c7c" stroke="#a94c4c" stroke-width="4"/>
        <polygon points="90,100 130,120 130,160 90,180 50,160 50,120" fill="#d97c7c" stroke="#a94c4c" stroke-width="4"/>
        <polygon points="210,160 250,180 250,220 210,240 170,220 170,180" fill="#bfc3c7" stroke="#a2a6aa" stroke-width="4"/>
        <polygon points="130,160 170,180 170,220 130,240 90,220 90,180" fill="#d1c2e9" stroke="#a580d9" stroke-width="4"/>
        <polygon points="170,220 210,240 210,280 170,300 130,280 130,240" fill="#a580d9" stroke="#7c9fd9" stroke-width="4"/>
      </g>
    </svg>
  </div>
  <div id="scoreboard"></div>
  <div id="game"></div>
  <div id="message"></div>
  <button id="reset">Reset Game</button>
  <div id="confetti" class="confetti" style="display:none"></div>
  <script>
    // Game config
    const COLS = 5;
    const ROWS = 8;
    const HEX_SIZE = 60;

    // State
    let playerPos = null; // {row, col}
    let playerTrail = []; // Array of {row, col, fade}
    let computerPos = [null, null, null]; // [{row, col}, {row, col}, {row, col}]
    // Only use computerPos[0] for level 1
    let turn = 0; // 0: player, 1: computer
    let gameOver = false;
    // Remove score, add lives
    let lives = 3;
    let collisionPos = null;
    let level = 1;
    let maxLevels = 6; // Now 6 levels
    let computerActiveCount = 1; // For level 3, how many computer tiles are active
    let playerTurnCount = 0; // For level 3, how many player moves have occurred
    // For future: maxLevels = N; (add more levels)
    // Debug mode state
    let debugMode = false;
    let lastDPress = 0;
    let winFadeRow = null;
    let winFadeTimer = null;
    let winColor = null; // 'red' or 'blue'
    let winFadeDirection = null; // 'down' or 'up'
    // Track previous computer positions for secret move logic
    let computerPrevPos = [null, null, null];
    // For computer move reveal
    let computerMoveReveal = null; // { positions: [ {row, col} ], timer: setTimeout }
    let computerLastMove = [null, null, null];
    // For row flash effect
    let flashRow = null; // { type: 'blue'|'red', row: number }
    // For gold flash and confetti
    let flashGold = false;

    // Generate honeycomb grid
    function createGrid() {
      const grid = [];
      for (let row = 0; row < ROWS; row++) {
        const rowArr = [];
        for (let col = 0; col < COLS; col++) {
          rowArr.push({ row, col, state: 'empty' });
        }
        grid.push(rowArr);
      }
      return grid;
    }
    let grid = createGrid();

    // DOM
    const gameDiv = document.getElementById('game');
    const messageDiv = document.getElementById('message');
    const resetBtn = document.getElementById('reset');

    function render() {
      // Scoreboard with colored box for turn
      const scoreboard = document.getElementById('scoreboard');
      scoreboard.innerHTML = '';
      const playerBox = document.createElement('div');
      playerBox.className = 'scorebox' + (turn === 0 ? ' active-player' : '');
      playerBox.textContent = `Player`;
      const computerBox = document.createElement('div');
      computerBox.className = 'scorebox' + (turn === 1 ? ' active-computer' : '');
      computerBox.textContent = `Hexpert`;
      const levelBox = document.createElement('div');
      levelBox.className = 'scorebox';
      levelBox.style.border = '3px solid #888';
      levelBox.style.background = '#f3f3f3';
      levelBox.style.display = 'flex';
      levelBox.style.flexDirection = 'column';
      levelBox.style.alignItems = 'flex-end';
      levelBox.innerHTML = `<div style="font-weight:bold;">Level: ${level}</div><span style="display:flex;gap:2px;">${[...Array(lives)].map(_ => `<svg width='18' height='20' viewBox='0 0 60 69' style='vertical-align:middle'><polygon points='15,4 45,4 58,34.5 45,65 15,65 2,34.5' fill='#e74c3c' stroke='#c0392b' stroke-width='2.5'/></svg>`).join('')}</span>`;
      scoreboard.appendChild(playerBox);
      scoreboard.appendChild(computerBox);
      // Add a flex spacer to push the level/lives box to the right
      const spacer = document.createElement('div');
      spacer.style.flex = '1';
      scoreboard.appendChild(spacer);
      scoreboard.appendChild(levelBox);

      gameDiv.innerHTML = '';
      for (let row = 0; row < ROWS; row++) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'row';
        // No margin-left; we stagger hexes instead
        for (let col = 0; col < COLS; col++) {
          const hex = document.createElement('div');
          hex.className = 'hex';
          // Stagger odd columns for honeycomb effect
          if (col % 2 === 1) hex.classList.add('stagger');
          // Mark start and goal rows
          if (row === ROWS - 1) hex.classList.add('start'); // player start (bottom)
          if (row === 0) hex.classList.add('goal'); // computer start (top)

          // Win animation: fill all hexes with color, fade by row
          if (winFadeRow !== null && winColor) {
            let fade = false;
            if (winFadeDirection === 'down') {
              fade = row < winFadeRow;
            } else if (winFadeDirection === 'up') {
              fade = row > (ROWS - 1 - winFadeRow);
            }
            if (fade) {
              hex.style.opacity = '0';
            } else {
              hex.style.opacity = '1';
              if (winColor === 'red') {
                hex.innerHTML = `<svg width='60' height='69' viewBox='0 0 60 69'><polygon points='15,4 45,4 58,34.5 45,65 15,65 2,34.5' fill='#e74c3c' stroke='#c0392b' stroke-width='4'/></svg>`;
              } else if (winColor === 'blue') {
                hex.innerHTML = `<svg width='60' height='69' viewBox='0 0 60 69'><polygon points='15,4 45,4 58,34.5 45,65 15,65 2,34.5' fill='#3498db' stroke='#217dbb' stroke-width='4'/></svg>`;
              }
            }
            rowDiv.appendChild(hex);
            continue;
          }

          // SVG hexagon
          const svgNS = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(svgNS, 'svg');
          svg.setAttribute('width', '60');
          svg.setAttribute('height', '69');
          svg.setAttribute('viewBox', '0 0 60 69');
          // Hexagon points
          const points = [
            [15, 4], [45, 4], [58, 34.5], [45, 65], [15, 65], [2, 34.5]
          ].map(p => p.join(",")).join(" ");
          const polygon = document.createElementNS(svgNS, 'polygon');
          polygon.setAttribute('points', points);
          svg.appendChild(polygon);

          // Add ghost pattern for computer-ghost
          if (row === 0 && col === 0) {
            const defs = document.createElementNS(svgNS, 'defs');
            const pattern = document.createElementNS(svgNS, 'pattern');
            pattern.setAttribute('id', 'ghostPattern');
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            pattern.setAttribute('width', '8');
            pattern.setAttribute('height', '8');
            const rect1 = document.createElementNS(svgNS, 'rect');
            rect1.setAttribute('x', '0');
            rect1.setAttribute('y', '0');
            rect1.setAttribute('width', '8');
            rect1.setAttribute('height', '8');
            rect1.setAttribute('fill', '#eaeaea');
            const rect2 = document.createElementNS(svgNS, 'rect');
            rect2.setAttribute('x', '0');
            rect2.setAttribute('y', '0');
            rect2.setAttribute('width', '4');
            rect2.setAttribute('height', '8');
            rect2.setAttribute('fill', '#3498db33');
            defs.appendChild(pattern);
            pattern.appendChild(rect1);
            pattern.appendChild(rect2);
            svg.appendChild(defs);
          }

          // Player
          if (playerPos && playerPos.row === row && playerPos.col === col) {
            hex.classList.add('player');
            if (collisionPos && collisionPos.row === row && collisionPos.col === col) {
              hex.classList.add('collision');
            }
          } else {
            // Check for player trail
            const trail = playerTrail.find(t => t.row === row && t.col === col);
            if (trail && trail.fade >= 1 && trail.fade <= 4) {
              hex.classList.add('trail-' + trail.fade);
            }
          }
          // Show computer's current position (all active tiles, 80% blue fill)
          let nComputers = (level >= 3 ? computerActiveCount : (level === 2 ? 2 : 1));
          if (playerPos) {
            if (computerMoveReveal && computerMoveReveal.positions.some(p => p.row === row && p.col === col)) {
              hex.classList.add('computer-reveal');
            } else if (computerMoveReveal == null && computerLastMove.some(p => p && p.row === row && p.col === col)) {
              hex.classList.add('computer-last');
            } else if (debugMode) {
              // In debug mode, show current computer positions ONLY
              for (let i = 0; i < nComputers; i++) {
                if (computerPos[i] && computerPos[i].row === row && computerPos[i].col === col) {
                  hex.classList.add('computer');
                }
              }
            }
          }
          // Add label (no C? label anymore)
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = '';
          hex.appendChild(svg);
          hex.appendChild(label);
          rowDiv.appendChild(hex);

          // Always add row number, but only visible in debug mode
          const rowNum = document.createElement('div');
          rowNum.style.position = 'absolute';
          rowNum.style.left = '4px';
          rowNum.style.top = '2px';
          rowNum.style.fontSize = '0.9em';
          rowNum.style.pointerEvents = 'none';
          rowNum.textContent = row;
          if (debugMode) {
            rowNum.style.color = '#666';
            rowNum.style.opacity = '1';
          } else {
            rowNum.style.color = '#bbb';
            rowNum.style.opacity = '0.1';
          }
          hex.appendChild(rowNum);

          // Add click handler (only if player's turn and valid move)
          if (!gameOver) {
            if (!playerPos && row === ROWS - 1 && turn === 0) {
              // Prevent player from picking a computer-occupied hex
              let occupied = false;
              nComputers = (level >= 3 ? computerActiveCount : (level === 2 ? 2 : 1));
              for (let i = 0; i < nComputers; i++) {
                if (computerPos[i] && computerPos[i].row === row && computerPos[i].col === col) {
                  occupied = true;
                }
              }
              if (!occupied) {
                hex.addEventListener('click', () => onHexClick(row, col));
              }
            } else if (
              playerPos &&
              turn === 0 &&
              isAdjacent(playerPos, { row, col }) &&
              !(playerPos.row === row && playerPos.col === col)
            ) {
              hex.addEventListener('click', () => onHexClick(row, col));
            }
          }

          // Flash effect for win row
          if (flashRow && row === flashRow.row) {
            hex.classList.add(flashRow.type === 'blue' ? 'flash-blue' : 'flash-red');
          }

          // Gold flash for win
          if (flashGold) {
            hex.classList.add('flash-gold');
          }
        }
        gameDiv.appendChild(rowDiv);
      }
    }

    function isAdjacent(a, b) {
      // Hex grid adjacency (even-q vertical layout)
      const even = a.col % 2 === 0;
      const directions = even
        ? [
            { dr: -1, dc: 0 },
            { dr: -1, dc: 1 },
            { dr: 0, dc: 1 },
            { dr: 1, dc: 0 },
            { dr: 0, dc: -1 },
            { dr: -1, dc: -1 },
          ]
        : [
            { dr: -1, dc: 0 },
            { dr: 1, dc: 1 },
            { dr: 0, dc: 1 },
            { dr: 1, dc: 0 },
            { dr: 0, dc: -1 },
            { dr: 1, dc: -1 },
          ];
      return directions.some(({ dr, dc }) => a.row + dr === b.row && a.col + dc === b.col);
    }

    function onHexClick(row, col) {
      if (gameOver) return;
      if (!playerPos) {
        playerTurnCount = 0;
        if (level === 4 || level === 5) {
          computerActiveCount = 3;
        } else if (level === 6) {
          computerActiveCount = 2;
        } else if (level === 3) {
          computerActiveCount = 1;
        } else if (level === 2) {
          computerActiveCount = 2;
        } else {
          computerActiveCount = 1;
        }
        // First move: must be bottom row
        if (row !== ROWS - 1) return;
        playerPos = { row, col };
        grid[row][col].state = 'player';
        playerTrail = [{ row, col, fade: 0 }];
        // Now set computer tiles and make their first move
        setInitialComputerTilesAndMove();
        turn = 1;
        render();
        setTimeout(computerMove, 700);
        return;
      } else if (turn === 0 && isAdjacent(playerPos, { row, col })) {
        // Update trail: increment fade for all, add new for current
        for (let t of playerTrail) t.fade++;
        playerTrail = playerTrail.filter(t => t.fade <= 4);
        playerTrail.push({ row: row, col: col, fade: 0 });
        // Player move
        playerPos = { row, col };
        // For level 3, increment player turn count and update active computer count
        if (level >= 3) {
          playerTurnCount++;
          if (playerTurnCount === 3) computerActiveCount = 2;
          if (playerTurnCount === 6) computerActiveCount = 3;
        }
        // Check for collision with computer (current position)
        let nComputers = (level >= 3 ? computerActiveCount : (level === 2 ? 2 : 1));
        let collision = false;
        for (let i = 0; i < nComputers; i++) {
          if (
            computerPos[i] &&
            computerPos[i].row === playerPos.row &&
            computerPos[i].col === playerPos.col
          ) {
            collision = true;
          }
        }
        if (collision) {
          gameOver = true;
          collisionPos = { row, col };
          lives--;
          // Flash top row blue before win fade
          flashRow = { type: 'blue', row: 0 };
          render();
          setTimeout(() => {
            flashRow = null;
            // Start lose animation: fill all blue, fade up
            winFadeRow = 0;
            winColor = 'blue';
            winFadeDirection = 'up';
            render();
            winFadeTimer = setInterval(() => {
              winFadeRow++;
              render();
              if (winFadeRow > ROWS) {
                clearInterval(winFadeTimer);
                winFadeRow = null;
                winColor = null;
                winFadeDirection = null;
                setTimeout(() => {
                  if (lives > 0) {
                    resetGame();
                  } else {
                    alert('Game Over!');
                    level = 1;
                    lives = 3;
                    resetGame();
                  }
                }, 400);
              }
            }, 120);
          }, 600);
          setTimeout(() => { collisionPos = null; render(); }, 800);
          return;
        }
        // Check for win (reach top row)
        if (row === 0) {
          gameOver = true;
          // Flash bottom row red before win fade
          flashRow = { type: 'red', row: ROWS - 1 };
          render();
          setTimeout(() => {
            flashRow = null;
            // Start win animation: fill all red, fade down
            winFadeRow = 0;
            winColor = 'red';
            winFadeDirection = 'down';
            render();
            winFadeTimer = setInterval(() => {
              winFadeRow++;
              render();
              if (winFadeRow > ROWS) {
                clearInterval(winFadeTimer);
                winFadeRow = null;
                winColor = null;
                winFadeDirection = null;
                setTimeout(() => {
                  if (level < maxLevels) {
                    level++;
                    playerPos = null;
                    computerPos = [null, null, null];
                    turn = 0;
                    gameOver = false;
                    playerTrail = [];
                    collisionPos = null;
                    winFadeRow = null;
                    winColor = null;
                    winFadeDirection = null;
                    playerTurnCount = 0;
                    if (level === 4 || level === 5) {
                      computerActiveCount = 3;
                    } else if (level === 6) {
                      computerActiveCount = 2;
                    } else if (level === 3) {
                      computerActiveCount = 1;
                    } else if (level === 2) {
                      computerActiveCount = 2;
                    } else {
                      computerActiveCount = 1;
                    }
                    if (winFadeTimer) clearInterval(winFadeTimer);
                    winFadeTimer = null;
                    grid = createGrid();
                    messageDiv.textContent = '';
                    render();
                  } else {
                    // Celebrate with gold flash and confetti
                    flashGold = true;
                    render();
                    showConfetti();
                    setTimeout(() => {
                      flashGold = false;
                      render();
                      setTimeout(() => {
                        level = 1;
                        resetGame();
                      }, 900);
                    }, 1100);
                  }
                }, 400);
              }
            }, 120);
          }, 600);
          return;
        }
        turn = 1;
        render();
        setTimeout(computerMove, 700);
      }
    }

    // --- Computer Strategies ---
    // Level 1: Pursuit (shortest path)
    function computerMoveLevel1(playerPos, computerPosArr) {
      // Only one computer tile
      let pos = computerPosArr[0];
      let moves = getComputerMoves(pos);
      // Remove moves that would land on the player
      const safeMoves = moves.filter(m => !(playerPos.row === m.row && playerPos.col === m.col));
      // 20% chance to stay in place
      if (Math.random() < 0.2) return [pos];
      let minDist = Infinity;
      let bestMoves = [];
      for (const m of safeMoves) {
        const dist = Math.abs(playerPos.row - m.row) + Math.abs(playerPos.col - m.col);
        if (dist < minDist) {
          minDist = dist;
          bestMoves = [m];
        } else if (dist === minDist) {
          bestMoves.push(m);
        }
      }
      const move = (bestMoves.length > 0)
        ? bestMoves[Math.floor(Math.random() * bestMoves.length)]
        : (safeMoves.length > 0 ? safeMoves[Math.floor(Math.random() * safeMoves.length)] : pos);
      return [move];
    }

    // Level 2: Random walk (avoids player)
    function computerMoveLevel2(playerPos, computerPosArr) {
      // Two computer tiles, only 20% chance to pick the same hex
      let moves0 = getComputerMoves(computerPosArr[0]);
      let moves1 = getComputerMoves(computerPosArr[1]);
      const safeMoves0 = moves0.filter(m => !(playerPos.row === m.row && playerPos.col === m.col));
      const safeMoves1 = moves1.filter(m => !(playerPos.row === m.row && playerPos.col === m.col));
      if (safeMoves0.length === 0 && safeMoves1.length === 0) return [computerPosArr[0], computerPosArr[1]];
      // Pick first move randomly
      const move0 = safeMoves0.length > 0 ? safeMoves0[Math.floor(Math.random() * safeMoves0.length)] : computerPosArr[0];
      // For the second move, 20% chance to pick the same as move0
      let move1;
      const canShare = safeMoves1.some(m => m.row === move0.row && m.col === move0.col);
      if (canShare && Math.random() < 0.2) {
        move1 = move0;
      } else {
        // Remove move0 from safeMoves1 if possible
        const filtered = safeMoves1.filter(m => !(m.row === move0.row && m.col === move0.col));
        if (filtered.length > 0) {
          move1 = filtered[Math.floor(Math.random() * filtered.length)];
        } else if (safeMoves1.length > 0) {
          move1 = safeMoves1[Math.floor(Math.random() * safeMoves1.length)];
        } else {
          move1 = computerPosArr[1];
        }
      }
      return [move0, move1];
    }

    // Level 3: Blocking (block player's path to top row)
    function computerMoveLevel3(playerPos, computerPosArr) {
      // Try to move to a hex in the row above the player, or block the column
      return computerPosArr.map(pos => {
        if (!pos) return null;
        // 20% chance to stay in place
        if (Math.random() < 0.2) return pos;
        let moves = getComputerMoves(pos);
        // Try to move to the row just above the player
        let blockMoves = moves.filter(m => m.row === playerPos.row - 1);
        if (blockMoves.length > 0) {
          return blockMoves[Math.floor(Math.random() * blockMoves.length)];
        }
        // Otherwise, try to move to the same column as the player
        let colMoves = moves.filter(m => m.col === playerPos.col);
        if (colMoves.length > 0) {
          return colMoves[Math.floor(Math.random() * colMoves.length)];
        }
        // Otherwise, fallback to pursuit
        let minDist = Infinity;
        let bestMoves = [];
        for (const m of moves) {
          const dist = Math.abs(playerPos.row - m.row) + Math.abs(playerPos.col - m.col);
          if (dist < minDist) {
            minDist = dist;
            bestMoves = [m];
          } else if (dist === minDist) {
            bestMoves.push(m);
          }
        }
        return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : pos;
      });
    }

    // Level 4: Ambush (predict player's next move and intercept)
    function computerMoveLevel4(playerPos, computerPosArr) {
      // Predict player's next move (assume up or up-left/up-right)
      let predictedMoves = [
        { row: playerPos.row - 1, col: playerPos.col },
        { row: playerPos.row - 1, col: playerPos.col - 1 },
        { row: playerPos.row - 1, col: playerPos.col + 1 }
      ];
      return computerPosArr.map(pos => {
        if (!pos) return null;
        // 20% chance to stay in place
        if (Math.random() < 0.2) return pos;
        let moves = getComputerMoves(pos);
        // Try to intercept predicted moves
        let intercept = moves.filter(m => predictedMoves.some(p => p.row === m.row && p.col === m.col));
        if (intercept.length > 0) {
          return intercept[Math.floor(Math.random() * intercept.length)];
        }
        // Otherwise, fallback to pursuit
        let minDist = Infinity;
        let bestMoves = [];
        for (const m of moves) {
          const dist = Math.abs(playerPos.row - m.row) + Math.abs(playerPos.col - m.col);
          if (dist < minDist) {
            minDist = dist;
            bestMoves = [m];
          } else if (dist === minDist) {
            bestMoves.push(m);
          }
        }
        return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : pos;
      });
    }

    // Level 5: Defensive (stay near top row, only move down if player is close)
    function computerMoveLevel5(playerPos, computerPosArr) {
      return computerPosArr.map(pos => {
        if (!pos) return null;
        // 20% chance to stay in place
        if (Math.random() < 0.2) return pos;
        let moves = getComputerMoves(pos);
        // Prefer moves that stay in row 0 or 1
        let topMoves = moves.filter(m => m.row <= 1);
        if (topMoves.length > 0) {
          return topMoves[Math.floor(Math.random() * topMoves.length)];
        }
        // If player is close (within 2 rows), move toward player
        if (playerPos.row <= 2) {
          let minDist = Infinity;
          let bestMoves = [];
          for (const m of moves) {
            const dist = Math.abs(playerPos.row - m.row) + Math.abs(playerPos.col - m.col);
            if (dist < minDist) {
              minDist = dist;
              bestMoves = [m];
            } else if (dist === minDist) {
              bestMoves.push(m);
            }
          }
          return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : pos;
        }
        // Otherwise, stay put
        return pos;
      });
    }

    // Level 6: Aggressive (move directly toward player, even if risking collision)
    function computerMoveLevel6(playerPos, computerPosArr) {
      return computerPosArr.map(pos => {
        if (!pos) return null;
        // 20% chance to stay in place
        if (Math.random() < 0.2) return pos;
        let moves = getComputerMoves(pos);
        // Always pick the move that minimizes distance to player, even if it means collision
        let minDist = Infinity;
        let bestMoves = [];
        for (const m of moves) {
          const dist = Math.abs(playerPos.row - m.row) + Math.abs(playerPos.col - m.col);
          if (dist < minDist) {
            minDist = dist;
            bestMoves = [m];
          } else if (dist === minDist) {
            bestMoves.push(m);
          }
        }
        return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : pos;
      });
    }

    // Strategy selector
    function getComputerMoveStrategy(level) {
      if (level === 1) return computerMoveLevel1;
      if (level === 2) return computerMoveLevel2;
      if (level === 3) return computerMoveLevel3;
      if (level === 4) return computerMoveLevel4;
      if (level === 5) return computerMoveLevel5;
      if (level === 6) return computerMoveLevel6;
      return computerMoveLevel1; // fallback
    }

    function computerMove() {
      if (gameOver) return;
      // Prevent computer from moving before player has moved
      if (!playerPos) return;
      // If computer tiles have not been set yet, set them now (after player's first move)
      if (!computerPos[0] || (level === 2 && !computerPos[1]) || (level === 3 && computerActiveCount > 1 && !computerPos[1]) || (level === 3 && computerActiveCount > 2 && !computerPos[2])) {
        const topHexes = [];
        for (let c = 0; c < COLS; c++) topHexes.push({ row: 0, col: c });
        if (level === 1) {
          const idx = Math.floor(Math.random() * topHexes.length);
          computerPos[0] = { row: 0, col: topHexes[idx].col };
          computerPos[1] = null;
          computerPos[2] = null;
        } else if (level === 2) {
          const indices = [...Array(topHexes.length).keys()];
          const idx1 = indices.splice(Math.floor(Math.random() * indices.length), 1)[0];
          const idx2 = indices[Math.floor(Math.random() * indices.length)];
          computerPos[0] = { row: 0, col: topHexes[idx1].col };
          computerPos[1] = { row: 0, col: topHexes[idx2].col };
          computerPos[2] = null;
        } else if (level === 3) {
          const idx = Math.floor(Math.random() * topHexes.length);
          computerPos[0] = { row: 0, col: topHexes[idx].col };
          computerPos[1] = null;
          computerPos[2] = null;
        } else {
          // For levels 4, 5, 6: fill up to computerActiveCount tiles in row 0, all in different columns
          let usedCols = [];
          for (let i = 0; i < computerActiveCount; i++) {
            const available = topHexes.filter(h => !usedCols.includes(h.col));
            if (available.length > 0) {
              const pick = available[Math.floor(Math.random() * available.length)];
              computerPos[i] = { row: 0, col: pick.col };
              usedCols.push(pick.col);
            } else {
              // If not enough unique columns, just pick any
              const pick = topHexes[Math.floor(Math.random() * topHexes.length)];
              computerPos[i] = { row: 0, col: pick.col };
            }
          }
          for (let i = computerActiveCount; i < 3; i++) {
            computerPos[i] = null;
          }
        }
      }
      let nComputers = (level >= 3 ? computerActiveCount : (level === 2 ? 2 : 1));
      // Prepare array of current positions for active tiles
      let activeComputerPos = [];
      for (let i = 0; i < nComputers; i++) {
        activeComputerPos.push(computerPos[i]);
      }
      // Get strategy for this level
      const strategy = getComputerMoveStrategy(level);
      // Save previous positions before moving
      for (let i = 0; i < nComputers; i++) {
        computerPrevPos[i] = computerPos[i] ? { ...computerPos[i] } : null;
      }
      // Save the last move (before this move)
      for (let i = 0; i < nComputers; i++) {
        computerLastMove[i] = computerPrevPos[i] ? { ...computerPrevPos[i] } : null;
      }
      // Compute new positions
      const newPositions = strategy(playerPos, activeComputerPos);
      // Get all possible moves for each computer tile (from current position)
      let allPossibleMoves = [];
      for (let i = 0; i < nComputers; i++) {
        if (computerPos[i]) {
          let moves = getComputerMoves(computerPos[i]);
          // Remove moves that would land on the player
          const safeMoves = moves.filter(m => !(playerPos.row === m.row && playerPos.col === m.col));
          // Add the current hex as a possible move (for 20% stay-in-place chance)
          safeMoves.push(computerPos[i]);
          allPossibleMoves.push(...safeMoves.map(m => `${m.row},${m.col}`));
        }
      }
      // Remove duplicates
      allPossibleMoves = Array.from(new Set(allPossibleMoves)).map(s => {
        const [row, col] = s.split(',').map(Number);
        return { row, col };
      });
      // Show all possible moves for 1 second
      computerMoveReveal = { positions: allPossibleMoves };
      render();
      setTimeout(() => {
        computerMoveReveal = null;
        // Set lastMove to the previous position (before the move)
        for (let i = 0; i < nComputers; i++) {
          computerLastMove[i] = computerPos[i] ? { ...computerPos[i] } : null;
        }
        // Now update computerPos to the new move
        for (let i = 0; i < nComputers; i++) {
          computerPos[i] = newPositions[i];
        }
        render();
      }, 1000);
      turn = 0;
    }

    function getComputerMoves(pos) {
      // Hex grid adjacency (even-q vertical layout)
      const even = pos.col % 2 === 0;
      const directions = even
        ? [
            { dr: -1, dc: 0 },
            { dr: -1, dc: 1 },
            { dr: 0, dc: 1 },
            { dr: 1, dc: 0 },
            { dr: 0, dc: -1 },
            { dr: -1, dc: -1 },
          ]
        : [
            { dr: -1, dc: 0 },
            { dr: 1, dc: 1 },
            { dr: 0, dc: 1 },
            { dr: 1, dc: 0 },
            { dr: 0, dc: -1 },
            { dr: 1, dc: -1 },
          ];
      const moves = [];
      for (const { dr, dc } of directions) {
        const nr = pos.row + dr;
        const nc = pos.col + dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
          moves.push({ row: nr, col: nc });
        }
      }
      return moves;
    }

    function resetGame() {
      playerPos = null;
      computerPos = [null, null, null];
      turn = 0; // Player goes first
      gameOver = false;
      playerTrail = [];
      collisionPos = null;
      winFadeRow = null;
      winColor = null;
      winFadeDirection = null;
      playerTurnCount = 0;
      if (level === 4 || level === 5) {
        computerActiveCount = 3;
      } else if (level === 6) {
        computerActiveCount = 2;
      } else if (level === 3) {
        computerActiveCount = 1;
      } else if (level === 2) {
        computerActiveCount = 2;
      } else {
        computerActiveCount = 1;
      }
      if (winFadeTimer) clearInterval(winFadeTimer);
      winFadeTimer = null;
      level = 1;
      grid = createGrid();
      messageDiv.textContent = '';
      // Do NOT set computer tiles or move yet; wait for player to pick
      computerMoveReveal = null;
      computerLastMove = [null, null, null];
      flashRow = null;
      flashGold = false;
      render();
    }

    function setInitialComputerTilesAndMove() {
      // Set computer tiles in row 0
      const topHexes = [];
      for (let c = 0; c < COLS; c++) topHexes.push({ row: 0, col: c });
      if (level === 1) {
        const idx = Math.floor(Math.random() * topHexes.length);
        computerPos[0] = { row: 0, col: topHexes[idx].col };
        computerPos[1] = null;
        computerPos[2] = null;
      } else if (level === 2) {
        const indices = [...Array(topHexes.length).keys()];
        const idx1 = indices.splice(Math.floor(Math.random() * indices.length), 1)[0];
        const idx2 = indices[Math.floor(Math.random() * indices.length)];
        computerPos[0] = { row: 0, col: topHexes[idx1].col };
        computerPos[1] = { row: 0, col: topHexes[idx2].col };
        computerPos[2] = null;
      } else if (level === 3) {
        const idx = Math.floor(Math.random() * topHexes.length);
        computerPos[0] = { row: 0, col: topHexes[idx].col };
        computerPos[1] = null;
        computerPos[2] = null;
      } else {
        // For levels 4, 5, 6: fill up to computerActiveCount tiles in row 0, all in different columns
        let usedCols = [];
        for (let i = 0; i < computerActiveCount; i++) {
          const available = topHexes.filter(h => !usedCols.includes(h.col));
          if (available.length > 0) {
            const pick = available[Math.floor(Math.random() * available.length)];
            computerPos[i] = { row: 0, col: pick.col };
            usedCols.push(pick.col);
          } else {
            // If not enough unique columns, just pick any
            const pick = topHexes[Math.floor(Math.random() * topHexes.length)];
            computerPos[i] = { row: 0, col: pick.col };
          }
        }
        for (let i = computerActiveCount; i < 3; i++) {
          computerPos[i] = null;
        }
      }
      // Computer makes first move
      let nComputers = (level >= 3 ? computerActiveCount : (level === 2 ? 2 : 1));
      let activeComputerPos = [];
      for (let i = 0; i < nComputers; i++) {
        activeComputerPos.push(computerPos[i]);
      }
      const strategy = getComputerMoveStrategy(level);
      const newPositions = strategy({row: -1, col: -1}, activeComputerPos); // No player yet
      for (let i = 0; i < nComputers; i++) {
        computerPos[i] = newPositions[i];
      }
      computerPrevPos = [null, null, null];
      computerLastMove = [null, null, null];
    }

    // For gold flash and confetti
    function showConfetti() {
      const confettiDiv = document.getElementById('confetti');
      confettiDiv.innerHTML = '';
      confettiDiv.style.display = '';
      const colors = ['#ffe066', '#d1c2e9', '#7c9fd9', '#d97c7c', '#bfc3c7', '#a580d9'];
      for (let i = 0; i < 32; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.background = colors[Math.floor(Math.random() * colors.length)];
        piece.style.left = Math.random() * 100 + 'vw';
        piece.style.top = (Math.random() * 10 - 5) + 'vh';
        piece.style.transform = `rotate(${Math.random() * 360}deg)`;
        confettiDiv.appendChild(piece);
      }
      setTimeout(() => { confettiDiv.style.display = 'none'; }, 1400);
    }

    resetBtn.addEventListener('click', () => {
      lives = 3;
      resetGame();
    });
    // Initial render
    resetGame();

    // Debug mode toggle: press 'd' twice quickly ("dd")
    window.addEventListener('keydown', (e) => {
      if (e.key === 'd' || e.key === 'D') {
        const now = Date.now();
        if (now - lastDPress < 500) {
          debugMode = !debugMode;
          render();
        }
        lastDPress = now;
      }
    });

    // Hide game UI until start
    document.getElementById('game').style.display = 'none';
    document.getElementById('scoreboard').style.display = 'none';
    document.getElementById('reset').style.display = 'none';
    document.getElementById('message').style.display = 'none';
    const startScreen = document.getElementById('startScreen');
    document.getElementById('startBtn').addEventListener('click', () => {
      startScreen.style.opacity = 0;
      setTimeout(() => {
        startScreen.style.display = 'none';
        document.getElementById('game').style.display = '';
        document.getElementById('scoreboard').style.display = '';
        document.getElementById('reset').style.display = '';
        document.getElementById('message').style.display = '';
      }, 400);
    });
  </script>
</body>
</html> 